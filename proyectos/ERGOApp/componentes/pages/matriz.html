<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matriz de Hallazgos</title>
    <link rel="stylesheet" href="../globals.css">

    <style>
        /* Estilos de la tabla usando variables de globals.css */
        .table-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: auto; /* Habilita el scroll vertical DENTRO del contenedor */
            max-height: 70vh; /* Limita la altura al 70% de la pantalla */
            border: 1px solid var(--gray-200, #e2e8f0);
            border-radius: var(--border-radius-lg, 12px);
            box-shadow: var(--shadow-sm, 0 1px 2px 0 rgb(0 0 0 / 0.04));
            background-color: #ffffff;
            min-height: 200px;
        }

        table {
            width: 100%;
            min-width: 1800px; /* Ancho mínimo para forzar scroll horizontal si es necesario */
            border-collapse: collapse;
            font-size: var(--text-sm, 0.75rem);
        }

        th,
        td {
            padding: 0.75rem 1rem; /* Espaciado interno */
            border-bottom: 1px solid var(--gray-200, #e2e8f0);
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* Forzar nowrap por defecto */
            text-align: center;
        }

        /* Encabezados de la tabla */
        thead th {
            background-color: var(--gray-50, #f8fafc);
            color: var(--gray-600, #475569);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap; /* Asegura que los headers no se rompan */
        }

        /* Celdas del cuerpo */
        tbody tr {
            /* --- AÑADIDO --- */
            cursor: pointer; /* Indica que la fila es interactiva */
            transition: background-color 0.2s ease;
        }

        tbody tr:hover {
            background-color: var(--gray-100, #f1f5f9);
        }

        td {
            color: var(--gray-700, #334155);
        }

        /* Estilos para descripciones (se aplica max-width) */
        td.wrap-text {
            max-width: 200px; /* Un ancho máximo mayor para celdas de texto */
            white-space: nowrap; /* Mantiene el nowrap por defecto */
            line-height: 2;
        }
    thead th:nth-child(3),
        tbody td:nth-child(3),
        thead th:nth-child(4),
        tbody td:nth-child(4) {
            max-width: 160px; /* Ancho más pequeño para forzar el salto */
            white-space: normal; /* Permitir salto de línea */
            vertical-align: middle;
            text-align: center;
        }
        /* --- AÑADIDO: Estilos para fila expandida --- */
        tbody tr.is-expanded td {
            white-space: normal; /* Permite que el texto se ajuste */
            overflow: visible;
            text-overflow: clip;
            max-height: none; /* Sin límite de altura */
            max-width: 400px; /* Ancho estándar al expandir */
        }

        /* Las celdas de texto largo pueden ser más anchas al expandirse */
        tbody tr.is-expanded td.wrap-text {
            max-width: 600px; 
        }

        /* Contenedor de filtros */
        .filter-container {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            /* Estilos de globals.css */
            background: white;
            border: 1px solid var(--gray-200);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
        }

        @media (min-width: 768px) {
            .filter-container {
                grid-template-columns: repeat(4, 1fr);
                align-items: end;
            }
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        .puestos-asignados-list {
            list-style-type: none; /* Quita el punto/viñeta */
            margin: 0;
            padding: 0;
        }
        .filter-group label {
            margin-bottom: 0.5rem;
            font-size: var(--text-sm, 0.75rem);
            font-weight: 500;
            color: var(--gray-700, #334155);
        }
        
        /* Layout del header */
        .page-header {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--gray-200);
            margin-bottom: 1.5rem;
        }
        
        .page-header h1 {
            font-size: 1.5rem; /* 24px */
            font-weight: 600;
            color: var(--gray-900);
        }

        @media (min-width: 640px) {
            .page-header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
        }

        /* --- Estilos del Modal Específico --- */ 
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="../localStorage-cache.js"></script>   
        <script src="../globals.js"></script>

    <script src="../supabase-config.js"></script>   
    <script src="../realtime-client.js"></script>
</head>

<body>
    <div class="main-content">

        <header class="page-header">
            <h1>Matriz de Hallazgos</h1>
        </header>

            <div class="filter-container">
            
            <div class="filter-group">
                <label for="filterAreaTopLevel">Área</label>
                <select id="filterAreaTopLevel" class="input-field">
                    <option value="">Todas las Áreas</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="filterCentro">Centro de Trabajo</label>
                <select id="filterCentro" class="input-field">
                    <option value="">Todos los Centros</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="filterTarea">Tarea Específica</label>
                <select id="filterTarea" class="input-field">
                    <option value="">Todas las Tareas</option>
                </select>
            </div>

            <div class="filter-group">
                <label>&nbsp;</label> <button id="clearFiltersBtn" type="button" class="btn btn-ghost">Limpiar Filtros</button>
            </div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Numero</th> <th>ID</th>
                        <th>Área</th>
                        <th>Centro de Trabajo</th>
                        <th>Descripción Detallada 
                             <br>del Hallazgo</th>
                        <th>Descripción del Riesgo</th>
                        <th>Grupo de Riesgo</th>
                        <th>Puesto Involucrado</th>
                        <th>Tarea Específica</th>
                        <th>Nivel de Riesgo <br> Identificado</th>
                        <th>Evaluación JNJ</th>
                        <th>Evaluación <br> Nom-036</th>
                        <th>Evaluación <br> Específica</th>
                        <th>Cumplimiento</th>
                        <th>Medida de Control <br> Propuesta</th>
                        <th>Nuevo Nivel de Riesgo</th>
                        <th>Tipo de Control</th>
                        <th>Comentarios</th>
                        <th>ART</th>
                        <th>Acción</th>
                        <th>Responsable</th>
                    </tr>
                </thead>
                <tbody id="hallazgosTableBody">
                    </tbody>
            </table>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            
            // --- DATOS GLOBALES ---
            let hallazgosData = []; // Almacenará los datos procesados de Supabase
            let workCentersData = [];
            let areasData = [];
            
            // Mapas para búsquedas rápidas
            let workCenterMap = new Map();
            let areaMap = new Map();
            let workCenterNameMap = new Map();
            let areaNameMap = new Map();
            let areaInitialsMap = new Map(); // Para las iniciales del ID

            // Listas para filtros (se llenarán después de cargar los datos)
            let centrosList = [];
            let areasTopLevelList = [];
            let tareasList = [];
            

            // --- REFERENCIAS AL DOM ---
            const hallazgosTableBody = document.getElementById('hallazgosTableBody');
            
            // Filtros
            const filterCentro = document.getElementById('filterCentro');
            const filterAreaTopLevel = document.getElementById('filterAreaTopLevel');
            const filterTarea = document.getElementById('filterTarea');
            const clearFiltersBtn = document.getElementById('clearFiltersBtn');

            // --- FUNCIONES ---

            /**
             * Expande o contrae una fila de la tabla
             * @param {HTMLElement} rowEl - El elemento <tr> clickeado
             */
            function toggleRowExpand(rowEl) {
                rowEl.classList.toggle('is-expanded');
            }
            // Hacer la función accesible globalmente para el onclick
            window.toggleRowExpand = toggleRowExpand;


            /**
             * Carga todos los datos necesarios de Supabase y los procesa.
             */
                async function loadAndProcessData() {
                try {
                    hallazgosTableBody.innerHTML = `<tr><td colspan="21" style="text-align: center; color: var(--gray-500); padding: 2rem;">Cargando datos...</td></tr>`;

                    // 1. Cargar datos base DIRECTAMENTE desde Supabase
                    const { data: wcData, error: wcError } = await window.dataClient.supabase
                        .from('work_centers')
                        .select('id, name');
                    
                    const { data: aData, error: aError } = await window.dataClient.supabase
                        .from('areas')
                        .select('id, name');

                    if (wcError) throw new Error(`Error cargando Centros: ${wcError.message}`);
                    if (aError) throw new Error(`Error cargando Áreas: ${aError.message}`);

                    workCentersData = wcData || [];
                    areasData = aData || [];
                    
                    // Cargar datos de área desde localStorage (dashboardData) como fallback
                    try {
                        const localDashboardData = JSON.parse(localStorage.getItem('dashboardData'));
                        if (Array.isArray(localDashboardData)) {
                            const areaIdsFromSupabase = new Set(areasData.map(a => a.id));
                            localDashboardData.forEach(area => {
                                if (area.id && area.name && !areaIdsFromSupabase.has(area.id)) {
                                    areasData.push({ id: area.id, name: area.name });
                                }
                            });
                        }
                    } catch (e) {
                        console.warn("No se pudo cargar 'dashboardData' desde localStorage", e);
                    }

                    // 2. Cargar todas las actividades (hallazgos)
                    const { data: evData, error: evError } = await window.dataClient.supabase
                        .from('evaluaciones')
                        .select('work_center_id, score_final, color_riesgo, created_at');
                    
                    if (evError) throw new Error(`Error cargando Evaluaciones: ${evError.message}`);

                    // 2.b. Procesar evaluaciones para encontrar la más reciente de cada centro
                    const latestEvals = new Map();
                    for (const ev of evData) {
                        const existing = latestEvals.get(ev.work_center_id);
                        if (!existing || new Date(ev.created_at) > new Date(existing.created_at)) {
                            latestEvals.set(ev.work_center_id, ev);
                        }
                    }
                    
                    // 2.c. Crear el mapa de Scores
                    const workCenterScoreMap = new Map();
                    for (const [centerId, ev] of latestEvals.entries()) {
                        workCenterScoreMap.set(centerId, {
                            scoreValue: `${parseFloat(ev.score_final || 0).toFixed(2)}%`,
                            scoreColor: ev.color_riesgo || '#6b7280' // default gray
                        });
                    }
const { data: actividadesData, error: actError } = await window.dataClient.supabase
                        .from('vista_hallazgos_cerrados')
                        .select('*'); 
                    
                    if (actError) throw new Error(`Error cargando Actividades: ${actError.message}`);

                    if (actError) throw new Error(`Error cargando Actividades: ${actError.message}`);

                    // --- INICIO DE MODIFICACIÓN 1: Cargar Puestos Asignados ---
                    const { data: puestosData, error: puestosError } = await window.dataClient.supabase
                        .from('centro_puestos')
                        .select('centro_id, puestos(nombre)'); // centro_id es la FK a work_centers
                    
                    if (puestosError) throw new Error(`Error cargando Puestos Asignados: ${puestosError.message}`);

                    // Agrupar los puestos por centro_id
                    const puestosAgrupados = new Map();
                    if (puestosData) {
                        for (const item of puestosData) {
                            const centerId = item.centro_id;
                            const puestoNombre = item.puestos?.nombre || 'Puesto Desconocido';
                            
                            if (!puestosAgrupados.has(centerId)) {
                                puestosAgrupados.set(centerId, new Set()); // Usar Set para evitar duplicados
                            }
                            puestosAgrupados.get(centerId).add(puestoNombre);
                        }
                    }
                    
                    // Crear el mapa de Puestos (con el HTML que quieres)
                    const workCenterPuestosMap = new Map();
                    for (const [centerId, puestosSet] of puestosAgrupados.entries()) {
                        const sortedPuestos = [...puestosSet].sort();
                        let html = '<ul class="puestos-asignados-list">';
                        sortedPuestos.forEach(puestoTexto => {
                            html += `<li>${puestoTexto}</li>`;
                        });
                        html += '</ul>';
                        workCenterPuestosMap.set(centerId, html);
                    }

                    // 3. Crear mapas para joins rápidos
                    workCenterMap = new Map(workCentersData.map(c => [c.id, c.name]));
                    areaMap = new Map(areasData.map(a => [a.id, a.name]));
                    workCenterNameMap = new Map(workCentersData.map(c => [c.name, c.id]));
                    areaNameMap = new Map(areasData.map(a => [a.name, a.id]));

                    // 4. --- INICIO: Lógica para INICIALES de Área ---
                    areaInitialsMap = new Map();
                    const generatedInitials = new Set();

                    // Ordenar áreas por nombre para asegurar un orden consistente
                    areasData.sort((a, b) => a.name.localeCompare(b.name));

                    areasData.forEach(area => {
                        let idBase = '';
                        const words = area.name.toUpperCase().split(' ').filter(w => w);
                        
                        if (words.length === 1) {
                            idBase = words[0].substring(0, 2); // Dos iniciales si es una palabra
                        } else if (words.length > 1) {
                            idBase = words[0][0] + words[1][0]; // Inicial de las dos primeras palabras
                        }

                        let finalInitials = idBase;
                        if (generatedInitials.has(finalInitials)) {
                            if (words.length === 1) {
                                idBase = words[0].substring(0, 3);
                            } else if (words.length > 1) {
                                idBase = words[0].substring(0, 2) + words[1][0];
                            }
                            finalInitials = idBase;
                        }
                        
                        let counter = 2;
                        let originalFinalInitials = finalInitials;
                        while (generatedInitials.has(finalInitials)) {
                            finalInitials = `${originalFinalInitials}${counter++}`;
                        }

                        generatedInitials.add(finalInitials);
                        areaInitialsMap.set(area.name, finalInitials); // Mapea Nombre -> Iniciales
                    });
                    // --- FIN: Lógica para INICIALES de Área ---

                    // 5. Procesar los datos de actividades (preliminar)
                    let preliminaryData = actividadesData.map(act => {
                        // Obtener el score del mapa que creamos
                        const scoreData = workCenterScoreMap.get(act.work_center_id) || {};

                        // Devolver el objeto
                        return {
                            // Nombres para mostrar y ordenar
                            areaTopLevel: areaMap.get(act.area_id) || act.area_id,
                            centro: workCenterMap.get(act.work_center_id) || act.work_center_id,
                            descripcion: act.descripcion_detallada,
                            riesgo: act.descripcion_riesgo,
                            grupoRiesgo: act.grupo_riesgo,
                            puesto: workCenterPuestosMap.get(act.work_center_id) || (act.puesto_involucrado || ''),
                            tarea: act.nombre,
                            nivelRiesgo: act.nivel_riesgo, // Se mantiene por si se usa en el modal
                            evaljnj: act.evaluacion_jnj,
                            evalnom: act.evaluacion_nom,
                            evaluacion: act.metodo,
                            cumplimiento: act.cumplimiento,
                            medidaControl: act.recomendaciones, // Mapeo de recomendaciones
                            nuevoNivelRiesgo: act.nuevo_nivel_riesgo,
                            tipoControl: act.tipo_control,
                            comentarios: act.comentarios,
                            art: act.art,
                            accion: act.accion,
                            responsable: act.responsable,
                            // --- DATOS DEL SCORE ---
                            scoreValue: scoreData.scoreValue,
                            scoreColor: scoreData.scoreColor
                        };
                    });

                    // 6. Ordenar los datos según la lógica de negocio
                    preliminaryData.sort((a, b) => {
                        if (a.areaTopLevel < b.areaTopLevel) return -1;
                        if (a.areaTopLevel > b.areaTopLevel) return 1;
                        if (a.centro < b.centro) return -1;
                        if (a.centro > b.centro) return 1;
                        if (a.tarea < b.tarea) return -1;
                        if (a.tarea > b.tarea) return 1;
                        return 0;
                    });

                    // 7. Asignar ID final y almacenar en la variable global
                    let areaCounter = 1;
                    let currentAreaName = null;

                    hallazgosData = preliminaryData.map((entry) => {
                        // Comprobar si es una nueva área
                        if (entry.areaTopLevel !== currentAreaName) {
                            currentAreaName = entry.areaTopLevel; // Actualizar el área actual
                            areaCounter = 1; // Reiniciar el contador
                        }

                        const numero = areaCounter; // Usar el contador específico del área
                        const iniciales = areaInitialsMap.get(entry.areaTopLevel) || 'ERR';
                        entry.id = `${numero}_${iniciales}`; // ID Personalizado (Ej: "1_MI")

                        areaCounter++; // Incrementar para el siguiente item de ESTA área
                        return entry;
                    });


                    // 8. Poblar listas de filtros (ahora que tenemos los datos)
                    centrosList = [...new Set(workCentersData.map(center => center.name))];
                    areasTopLevelList = [...new Set(areasData.map(area => area.name))];
                    tareasList = [...new Set(hallazgosData.map(h => h.tarea))];

                    // 9. Poblar los <select> de los filtros
                    populateSelect(filterAreaTopLevel, areasTopLevelList, 'Todas las Áreas');
                    populateSelect(filterCentro, centrosList, 'Todos los Centros');
                    populateSelect(filterTarea, tareasList, 'Todas las Tareas');

                    // 10. Renderizar la tabla
                    applyFilters();

                } catch (error) {
                    console.error("Error al cargar datos:", error);
                    hallazgosTableBody.innerHTML = `<tr><td colspan="21" style="text-align: center; color: red; padding: 2rem;">Error al cargar los datos: ${error.message}</td></tr>`;
                }
            }

            function populateSelect(selectEl, optionsList, defaultOptionText) {
                const currentValue = selectEl.value;
                selectEl.innerHTML = ''; // Limpiar opciones existentes
                
                // Agregar opción por defecto
                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.textContent = defaultOptionText;
                selectEl.appendChild(defaultOption);

                // Agregar opciones de la lista
                const uniqueOptions = [...new Set(optionsList)].sort();
                uniqueOptions.forEach(optionText => {
                    const option = document.createElement('option');
                    option.value = optionText; // El valor es el mismo texto (para filtros)
                    option.textContent = optionText;
                    selectEl.appendChild(option);
                });

                // Restaurar valor previo si aún existe
                if (Array.from(selectEl.options).some(opt => opt.value === currentValue)) {
                    selectEl.value = currentValue;
                }
            }

            function updateDependentFilters() {
                const selectedArea = filterAreaTopLevel.value;
                const selectedCentro = filterCentro.value;

                // 1. Filtrar los Centros basado en el Área
                let centrosFiltrados = [];
                if (selectedArea) {
                    // Obtener los IDs de centro que pertenecen al área seleccionada
                    const centerIdsInArea = workCentersData
                        .filter(c => areaMap.get(c.area_id) === selectedArea)
                        .map(c => c.id);
                    // Ahora filtrar los hallazgos que usan esos IDs
                    centrosFiltrados = [...new Set(hallazgosData
                        .filter(h => h.areaTopLevel === selectedArea)
                        .map(h => h.centro))];
                } else {
                    // Si no hay área, mostrar todos los centros
                    centrosFiltrados = [...new Set(hallazgosData.map(h => h.centro))];
                }
                populateSelect(filterCentro, centrosFiltrados, 'Todos los Centros');
                filterCentro.value = selectedCentro; // Intentar restaurar la selección previa

                // 2. Filtrar Tareas basado en Área y Centro
                let tareasFiltradas = [];
                if (selectedArea && selectedCentro) {
                    // Ambas seleccionadas
                    tareasFiltradas = [...new Set(hallazgosData
                        .filter(h => h.areaTopLevel === selectedArea && h.centro === selectedCentro)
                        .map(h => h.tarea))];
                } else if (selectedArea) {
                    // Solo Área seleccionada
                    tareasFiltradas = [...new Set(hallazgosData
                        .filter(h => h.areaTopLevel === selectedArea)
                        .map(h => h.tarea))];
                } else {
                    // Ningún filtro o solo centro (que no depende de nada)
                    tareasFiltradas = [...new Set(hallazgosData.map(h => h.tarea))];
                }
                populateSelect(filterTarea, tareasFiltradas, 'Todas las Tareas');
            }

/**
             * Renderiza la tabla de hallazgos con los datos proporcionados
             * @param {object[]} data - Array de objetos de hallazgos
             */
            function renderTable(data) {
                hallazgosTableBody.innerHTML = ''; // Limpiar tabla

                if (data.length === 0) {
                    hallazgosTableBody.innerHTML = `<tr><td colspan="21" style="text-align: center; color: var(--gray-500); padding: 2rem;">No se encontraron hallazgos.</td></tr>`;
                    return;
                }

                let lastCentroName = null;
                // Usamos un loop 'for' clásico para controlar el índice 'i'
                for (let i = 0; i < data.length; i++) {
                    const entry = data[i];
                    const row = document.createElement('tr');
                    row.setAttribute('onclick', 'toggleRowExpand(this)');
                    
                    let rowHTML = '';

                    // Construir la primera parte de la fila (antes de la celda fusionada)
                    rowHTML += `
                        <td>${i + 1}</td>
                        <td>${entry.id}</td>
                        <td>${entry.areaTopLevel || ''}</td>
                        <td>${entry.centro || ''}</td>
                        <td class="wrap-text">${entry.descripcion || ''}</td>
                        <td class="wrap-text">${entry.riesgo || ''}</td>
                        <td>${entry.grupoRiesgo || ''}</td>
                        <td>${entry.puesto || ''}</td>
                        <td>${entry.tarea || ''}</td>
                    `;

                    // --- INICIO: Lógica de Rowspan ---
                    // ¿Es este un centro de trabajo diferente al anterior?
                    if (entry.centro !== lastCentroName) {
                        // 1. Calcular el rowspan
                        let rowspanCount = 1;
                        // Mirar filas adelante
                        for (let j = i + 1; j < data.length; j++) {
                            if (data[j].centro === entry.centro) {
                                rowspanCount++;
                            } else {
                                break; // Parar cuando el nombre del centro cambie
                            }
                        }

                        // 2. Añadir la celda fusionada
                            rowHTML += `
                            <td rowspan="${rowspanCount}" style="
                                background-color: ${entry.scoreColor || '#f1f5f9'}; 
                                color: #ffffff; 
                                vertical-align: middle; 
                                text-align: center; 
                                font-weight: bold; 
                                white-space: normal;
                                font-size: 2rem;
                            ">
                                ${entry.scoreValue || '--'}
                            </td>
                        `;
                        
                        // 3. Actualizar el último centro procesado
                        lastCentroName = entry.centro;
                    }
                    // Si NO es un centro nuevo (else), simplemente no añadimos la celda
                    // y HTML la omitirá correctamente gracias al rowspan de la fila anterior.
                    // --- FIN: Lógica de Rowspan ---

                    // Construir el resto de la fila (después de la celda fusionada)
                    rowHTML += `
                        <td>${entry.evaluacion_jnj || ''}</td>
                        <td>${entry.evaluacion_nom || ''}</td>
                        <td>${entry.evaluacion || ''}</td>
                        <td>${entry.cumplimiento || ''}</td>
                        <td class="wrap-text">${entry.medidaControl || ''}</td>
                        <td>${entry.nuevoNivelRiesgo || ''}</td>
                        <td>${entry.tipoControl || ''}</td>
                        <td class="wrap-text">${entry.comentarios || ''}</td>
                        <td>${entry.art || ''}</td>
                        <td>${entry.accion || ''}</td>
                        <td>${entry.responsable || ''}</td>
                    `;

                    row.innerHTML = rowHTML;
                    hallazgosTableBody.appendChild(row);
                }
            }

            /**
             * Aplica los filtros seleccionados a los datos y vuelve a renderizar la tabla
             */
/**
             * Aplica los filtros seleccionados a los datos y vuelve a renderizar la tabla
             */
            function applyFilters() {
                const selectedCentro = filterCentro.value;
                const selectedAreaTopLevel = filterAreaTopLevel.value;
                const selectedTarea = filterTarea.value;

                // --- MODIFICADO ---
                // Actualizar las opciones de los filtros dependientes ANTES de filtrar la tabla
                updateDependentFilters();
                // --- FIN MODIFICADO ---

                const filteredData = hallazgosData.filter(entry => {
                    // Filtra por los nombres, que es lo que está en los <select>
                    const matchCentro = !selectedCentro || entry.centro === selectedCentro;
                    const matchAreaTopLevel = !selectedAreaTopLevel || entry.areaTopLevel === selectedAreaTopLevel;
                    const matchTarea = !selectedTarea || entry.tarea === selectedTarea;
                    return matchCentro && matchAreaTopLevel && matchTarea;
                });

                renderTable(filteredData);
            }

            function clearFilters() {
                filterCentro.value = "";
                filterAreaTopLevel.value = "";
                filterTarea.value = "";
                
                // Repoblar los filtros con todas las opciones
                populateSelect(filterAreaTopLevel, areasTopLevelList, 'Todas las Áreas');
                populateSelect(filterCentro, centrosList, 'Todos los Centros');
                populateSelect(filterTarea, tareasList, 'Todas las Tareas');

                applyFilters();
            }

            // --- INICIALIZACIÓN Y EVENT LISTENERS ---

            // Cargar datos al iniciar
            await loadAndProcessData();

            // Listeners para filtros
            filterCentro.addEventListener('change', applyFilters);
            filterAreaTopLevel.addEventListener('change', () => {
                // Si cambias el Área, resetea el Centro
                filterCentro.value = "";
                applyFilters();
            });
            filterCentro.addEventListener('change', applyFilters);
            filterTarea.addEventListener('change', applyFilters);
            clearFiltersBtn.addEventListener('click', clearFilters);

        });8
        
    </script>
    <script src="../header-component.js"></script>
    </body>

</html>